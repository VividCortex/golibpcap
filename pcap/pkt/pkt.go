// Copyright 2012 The golibpcap Authors. All rights reserved.                      
// Use of this source code is governed by a BSD-style                              
// license that can be found in the LICENSE file.

// The pkt package provides access to the packet internals.                        
//
package pkt

import (
	"fmt"
	"strings"
)

// These indices can be used with the []Hdr generated by NewPacket to access
// common headers.
const (
	LinkLayer      = 0 // Index for OSI Data Link Layer in Pkt.Headers
	NetworkLayer   = 1 // Index for OSI Network Layer in Pkt.Headers
	TransportLayer = 2 // Index for OSI Transport Layer in Pkt.Headers
)

// These two-octet constants can be compared with the captured value to indicate
// which protocol is encapsulated in the payload of an Ethernet Frame.
const (
	EtherTypeIPv4 = uint16(0x0800) // Internet Protocol version 4
	EtherTypeIPv6 = uint16(0x86DD) // Internet Protocol version 6
	EtherTypeARP  = uint16(0x0806) // Address Resolution Protocol
)

// These IP protocol numbers are used in the Protocol field of the IPv4 header
// and the Next Header field of IPv6 header.
const (
	IpProtoTCP = uint8(0x06) // Transmission Control Protocol (TCP)
	IpProtoUDP = uint8(0x11) // User Datagram Protocol (UDP)
)

// The Hdr interface allows us to deal with an array of headers.
type Hdr interface {
	JsonElement() string
	CsvElement() string
	String() string
}

// JsonString  returns a JSON encoding of the Packet struct.
func (p *Packet) JsonString() string {
	s := make([]string, len(p.Headers))
	for i := range p.Headers {
		if p.Headers[i] == nil {
			break
		}
		s[i] = p.Headers[i].JsonElement()
	}
	return fmt.Sprintf("{\"time\":%d,%s}", p.Time.UnixNano(), strings.Join(s, ","))
}

// CsvString  returns a CSV encoding of the Packet struct.
// Each header type has a unique string that marks the beginning of the CSV
// fields for that particular header.
func (p *Packet) CsvString() string {
	s := make([]string, len(p.Headers))
	for i := range p.Headers {
		if p.Headers[i] == nil {
			break
		}
		s[i] = p.Headers[i].CsvElement()
	}
	return fmt.Sprintf("%d,%s", p.Time.UnixNano(), strings.Join(s, ","))
}

// String returns a minimal encoding of the Packet struct.
func (p *Packet) String() string {
	s := make([]string, len(p.Headers))
	for i := range p.Headers {
		if p.Headers[i] == nil {
			break
		}
		s[i] = p.Headers[i].String()
	}
	return fmt.Sprintf("%s %s", p.Time, strings.Join(s, " "))
}
